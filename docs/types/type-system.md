# Система типів TypeScript
Ми розглянули основні функції системи типів TypeScript, коли обговорювали [Чому TypeScript?](../why-typescript.md). Ось кілька ключових моментів з цієї дискусії, які не потребують додаткового пояснення:
* Система типів у TypeScript розроблена таким чином, щоб бути *необов'язковою*, тому що *ваш JavaScript є TypeScript*.
* TypeScript не блокує *JavaScript emit* в разі наявності помилок типів, дозволяючи вам *поступово оновлювати ваш JS до TS*.

Тепер давайте розпочнемо з *синтаксису* системи типів TypeScript. Таким чином, ви можете почати використовувати ці анотації в своєму коді негайно і побачити їх перевагу. Це підготує вас до більш глибокого дослідження пізніше.

## Основні анотації
Як вже згадувалося раніше, типи анотуються за допомогою синтаксису `:TypeAnnotation`. Будь-що, що доступне в просторі імен декларації типів, може бути використано як анотація типу.

Наступний приклад демонструє анотації типів для змінних, параметрів функцій та значень, що повертаються функцією:

```ts
var num: number = 123;
function identity(num: number): number {
    return num;
}
```

### Примітивні типи
Примітивні типи JavaScript добре представлені в системі типів TypeScript. Це означає, що `string`, `number`, `boolean` представлені нижче:

```ts
var num: number;
var str: string;
var bool: boolean;

num = 123;
num = 123.456;
num = '123'; // Помилка

str = '123';
str = 123; // Помилка

bool = true;
bool = false;
bool = 'false'; // Помилка
```

### Масиви
TypeScript надає відповідний синтаксис типу для масивів, щоб зробити його простішим для анотування та документування вашого коду. Синтаксис полягає в тому, що потрібно додати `[]` до будь-якої дійсної анотації типу (наприклад, `:boolean[]`). Це дозволяє вам безпечно виконувати будь-яку маніпуляцію з масивами, яку ви зазвичай робите, і захищає вас від помилок, таких як присвоєння члена неправильного типу. Це демонструється нижче:

```ts
var boolArray: boolean[];

boolArray = [true, false];
console.log(boolArray[0]); // true
console.log(boolArray.length); // 2
boolArray[1] = true;
boolArray = [false, false];

boolArray[0] = 'false'; // Помилка!
boolArray = 'false'; // Помилка!
boolArray = [true, 'false']; // Помилка!
```

### Інтерфейси
Інтерфейси є основним способом в TypeScript для складання кількох анотацій типів в одну іменовану анотацію. Розгляньте наступний приклад:

```ts
interface Name {
    first: string;
    second: string;
}

var name: Name;
name = {
    first: 'John',
    second: 'Doe'
};

name = {           // Помилка: відсутній `second`
    first: 'John'
};
name = {           // Помилка: `second` має неправильний тип
    first: 'John',
    second: 1337
};
```

Тут ми склали анотації `first: string` + `second: string` в нову анотацію `Name`, яка забезпечує перевірку типів для окремих членів. Інтерфейси мають багато потужностей в TypeScript, і ми приділимо цілу секцію тому, як ви можете використовувати їх на свою користь.

### Анотація типу в одному рядку
Замість створення нового `interface` ви можете анотувати будь-що, що вам потрібно *в одному рядку* за допомогою `:{ /*Структура*/ }`. Попередній приклад представлений знову з анотацією типу в одному рядку:

```ts
var name: {
    first: string;
    second: string;
};
name = {
    first: 'John',
    second: 'Doe'
};

name = {           // Помилка: відсутній `second`
    first: 'John'
};
name = {           // Помилка: `second` має неправильний тип
    first: 'John',
    second: 1337
};
```

Анотації в одному рядку чудово підходять для швидкого надання анотації типу для чогось одного разу. Це заощаджує вам клопоту придумування (потенційно поганого) імені типу. Однак, якщо ви помічаєте, що ви використовуєте одну і ту ж анотацію типу в одному рядку кілька разів, розгляньте можливість рефакторингу її в інтерфейс (або в `type alias`, який буде розглянуто пізніше в цьому розділі).

## Спеціальні типи
Окрім примітивних типів, які були розглянуті, існує кілька типів, які мають особливе значення в TypeScript. Це `any`, `null`, `undefined`, `void`.

### any
Тип `any` займає особливе місце в системі типів TypeScript. Він дає вам вихід з системи типів, щоб сказати компілятору "відстань". `any` сумісний з *будь-якими* типами в системі типів. Це означає, що *до нього можна присвоїти будь-що* і *його можна присвоїти будь-чому*. Це демонструється в прикладі нижче:

```ts
var power: any;

// Приймає будь-які типи
power = '123';
power = 123;

// Сумісний з усіма типами
var num: number;
power = num;
num = power;
```

Якщо ви переносите код JavaScript в TypeScript, ви будете добрими друзями з `any` на початку. Однак не беріть цю дружбу занадто серйозно, оскільки це означає, що *вам потрібно забезпечити безпеку типів*. Ви фактично кажете компілятору *не виконувати жодного значущого статичного аналізу*.

### `null` та `undefined`

Те, як вони обробляються системою типів, залежить від прапорця компілятора `strictNullChecks` (ми розглянемо цей прапорець пізніше). У режимі `strictNullCheck:false` літерали JavaScript `null` та `undefined` ефективно обробляються системою

```ts
interface Array<T> {
 reverse(): T[];
 // ...
}
```

Це означає, що ви отримуєте безпеку типів при виклику `.reverse` на будь-якому масиві, як показано нижче:

```ts
var numArr = [1, 2];
var reversedNums = numArr.reverse();

reversedNums = ['1', '2']; // Помилка!
```

Ми розглянемо більше про інтерфейс `Array<T>` пізніше, коли представимо `lib.d.ts` в розділі **Ambient Declarations**.

## Об'єднані типи
Досить часто в JavaScript ви хочете дозволити властивості бути одним з кількох типів, наприклад *`string` або `number`*. Це те, де корисний *об'єднаний тип* (позначений `|` в анотації типу, наприклад, `string|number`). Частим випадком є функція, яка може приймати один об'єкт або масив об'єктів, наприклад:

```ts
function formatCommandline(command: string[]|string) {
    var line = '';
    if (typeof command === 'string') {
        line = command.trim();
    } else {
        line = command.join(' ').trim();
    }

    // Do stuff with line: string
}
```

## Перетин типів
`extend` є дуже поширеним шаблоном в JavaScript, де ви берете два об'єкти і створюєте новий, який має можливості обох цих об'єктів. **Тип перетину** дозволяє використовувати цей шаблон у безпечний спосіб, як показано нижче:

```ts
function extend<T, U>(first: T, second: U): T & U {
  return { ...first, ...second };
}

const x = extend({ a: "hello" }, { b: 42 });

// x тепер має як `a`, так і `b`
const a = x.a;
const b = x.b;
```

## Тип кортежу
JavaScript не має підтримки кортежів першого класу. Люди, як правило, просто використовують масив як кортеж. Точно так само підтримує система типів TypeScript. Кортежі можна анотувати за допомогою `: [typeofmember1, typeofmember2]` і т.д. Кортеж може мати будь-яку кількість членів. Кортежі продемонстровано в наведеному нижче прикладі:

```ts
var nameNumber: [string, number];

// Добре
nameNumber = ['Jenny', 8675309];

// Помилка!
nameNumber = ['Jenny', '867-5309'];
```

Поєднайте це з підтримкою деструктуризації в TypeScript, і кортежі відчуваються досить першокласними, незважаючи на те, що вони є масивами під капотом:

```ts
var nameNumber: [string, number];
nameNumber = ['Jenny', 8675309];

var [name, num] = nameNumber;
```

## Псевдонім типу
TypeScript надає зручний синтаксис для надання імені анотації типу, яку ви хотіли б використовувати в більш ніж одному місці. Псевдоніми створюються за допомогою синтаксису `type SomeName = someValidTypeAnnotation`. Нижче наведено приклад:

```ts
type StrOrNum = string|number;

// Використання: як будь-яка інша анотація
var sample: StrOrNum;
sample = 123;
sample = '123';

// Просто перевірка
sample = true; // Помилка!
```

На відміну від інтерфейсу, ви можете дати псевдонім типу буквально будь-якій анотації типу (корисно для речей, таких як об'єднані та перетинні типи). Ось кілька додаткових прикладів, щоб ви ознайомилися з синтаксисом:

```ts
type Text = string | { text: string };
type Coordinates = [number, number];
type Callback = (data: string) => void;
```

> PORADA: Якщо вам потрібно мати ієрархії анотацій типів, використовуйте інтерфейс. Їх можна використовувати з `implements` та `extends`

> PORADA: Використовуйте псевдонім типу для простіших структур об'єктів (наприклад, `Coordinates`), щоб надати їм семантичне ім'я. Крім того, коли ви хочете дати семантичні імена об'єднаним або перетинним типам, псевдонім типу - це правильний вибір.

## Резюме
Тепер, коли ви можете починати анотувати більшість вашого коду JavaScript, ми можемо перейти до деталей всієї потужності, доступної в системі типів TypeScript.