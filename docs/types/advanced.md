



# Functions

## Optional
Опціональні.

Анотацію `?` можна використовувати перед аргументом функції або членом інтерфейсу, щоб позначити, що член є необов’язковим. Тобто ви можете надати його, якщо хочете (і його тип буде перевірено), але якщо він пропущений, це *okay*. Це показано в наступному прикладі:

## Specialized Parameters
Спеціалізовані параметри.

## Function Overloads
Перезавантаження функцій.

Середовище виконання JavaScript не підтримує перевантаження функцій. Для будь-якого даного імені функції в області бачення (scope) може бути лише одне тіло функції. Однак люди підтримують перевантаження функцій, використовуючи високодинамічний характер JavaScript, наприклад. геттер і сеттер:

```ts
var _value;
function getOrSet(value) {
    if (value === undefined) {
        return _value;
    } else {
        _value = value;
    }
}

getOrSet(1); // set : 1
console.log(getOrSet()); // get : 1
```

Така реалізація може бути зафіксована системою типів TypeScript шляхом надання сигнатур функції перед реалізацією функції:

```ts
var _value;
function getOrSet(): number;
function getOrSet(value: number);
function getOrSet(value?: number) {
    if (value === undefined) {
        return _value;
    } else {
        _value = value;
    }
}

getOrSet(1); // set : 1
console.log(getOrSet()); // get : 1
```

Зауважте, що коли ви визначаєте перевантаження функцій таким чином, *the last signature is actually not callable*. Однак ви повинні надати це, щоб допомогти реалізатору функції знати про наслідки його перевантаження підписів. Наприклад, у наступному прикладі функція з сигнатурою `function callMe(v1?: any, v2?: any): any` не відкрита для загального використання:

```ts
function callMe(): number;
function callMe(v1: number);
function callMe(v1: string, v2: number);
function callMe(v1?: any, v2?: any): any {
    // тіло функції
}

// доступні виклики
callMe();
callMe(1);
callMe('jenny', 5309);

// COMPILER ERROR: помилкові виклики
callMe('jenny');
callMe('jenny', '5309');
```

ПОРАДА. Зверніть увагу, що типи об’єднань і перевантаження функцій незначно збігаються. Якщо дві сигнатури функцій відрізняються лише одним параметром, що має різні типи, просто використовуйте тип об’єднання для цього параметра замість створення сигнатури перевантаження.


# Interfaces
Інтерфейси.

Інтерфейси мають велику силу в TypeScript. Це тому, що вони розроблені, щоб охопити всю складність




# Ambient Declarations
Декларації середовища.

Раніше ми мали короткий огляд декларацій середовища в розділі *why typescript?*. Однією з основних цілей розробки TypeScript є можливість легкого використання існуючих бібліотек JavaScript. Ви можете оголосити інформацію про тип для існуючого JavaScript за допомогою *ambient declarations*. Ви оголошуєте навколишній матеріал за допомогою ключового слова `declare`. Насправді це те, як купа речей, доступних за замовчуванням у середовищі браузера (наприклад, `window`, `document` тощо), оголошується у файлі під назвою `lib.d.ts`


Примітка. Ви можете знайти визначення типів для майже 90% найпопулярніших бібліотек JavaScript на [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped) за допомогою [lots of  developers](https://github.com/borisyankov/DefinitelyTyped/graphs/contributors).



### lib.d.ts

# Interfaces



### Interfaces for primitive types

### Interface for array

## Type Alias

## Union Types
необхідні для конфігурації об’єктів

## Type Inference
Він намагається *вивести* стільки, скільки може, *щоб вам не потрібно було явно вводити* свій код.

## Function Signatures

Спеціалізовані

## Type Assertion

Якщо A є підтипом B або B є підтипом A.








[більше про інтерфейси]
Структурний, тому більше інформації — це добре, але менше інформації — це помилка. Збиточна типізація глибоко вкорінений у мовний дизайн.
Відкритий для доповнення
Сумісность типів
