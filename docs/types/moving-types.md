# Типи переміщення

Система типів TypeScript надзвичайно потужна і дозволяє переміщувати та розрізати типи таким чином, який неможливий в будь-якій іншій мові програмування.

Це тому, що TypeScript розроблений таким чином, щоб дозволяти вам безшовно працювати з *високодинамічною* мовою, такою як JavaScript. Тут ми розглянемо кілька прийомів переміщення типів в TypeScript.

Основна мотивація для цього: ви змінюєте одну річ, і все інше автоматично оновлюється, а якщо щось зламалося, ви отримуєте гарні помилки, як у добре розробленій системі обмежень.

## Копіювання як тип, так і значення

Якщо ви хочете перемістити клас, ви можете спробувати зробити наступне:

```ts
class Foo { }
var Bar = Foo;
var bar: Bar; // ПОМИЛКА: не вдалося знайти ім'я 'Bar'
```

Це помилка, оскільки `var` скопіював лише `Foo` в простір оголошення *змінних*, і ви не можете використовувати `Bar` як анотацію типу. Правильним способом є використання ключового слова `import`. Зверніть увагу, що ви можете використовувати ключове слово `import` таким чином, якщо ви використовуєте *простори імен* або *модулі* (про це далі):

```ts
namespace importing {
    export class Foo { }
}

import Bar = importing.Foo;
var bar: Bar; // Ок
```

Цей трюк `import` працює лише для речей, які є *одночасно типом і змінною*.

## Захоплення типу змінної

Ви можете фактично використовувати змінну в анотації типу, використовуючи оператор `typeof`. Це дозволяє вам повідомити компілятору, що одна змінна має той самий тип, що й інша. Ось приклад для демонстрації цього:

```ts
var foo = 123;
var bar: typeof foo; // `bar` має той самий тип, що й `foo` (тут `number`)
bar = 456; // Ок
bar = '789'; // ПОМИЛКА: Тип `string` не є `assignable` до типу `number`
```

## Захоплення типу члена класу

Ви можете перейти в будь-який ненульовий об'єктний тип, щоб отримати тип властивості:

```ts
class Foo {
  foo: number; // деякий член, тип якого ми хочемо захопити
}

let bar: Foo['foo']; // `bar` має тип `number`
```

Альтернативно, подібно до захоплення типу змінної, ви просто оголошуєте змінну виключно для захоплення типу:

```ts
// Чисто для захоплення типу
declare let _foo: Foo;

// Те саме, що й раніше
let bar: typeof _foo.foo; // `bar` має тип `number`
```

## Захоплення типу магічних рядків

Багато бібліотек та фреймворків JavaScript працюють зі звичайними рядками JavaScript. Ви можете використовувати змінні `const`, щоб захопити їх тип, наприклад:

```ts
// Захоплення як *типу*, так і *значення* магічного рядка:
const foo = "Hello World";

// Використання захопленого типу:
let bar: typeof foo;

// bar може бути призначений лише `Hello World`
bar = "Hello World"; // Ок!
bar = "anything else "; // Помилка!
```

У цьому прикладі `bar` має літеральний тип `"Hello World"`. Ми докладніше розглянемо це в розділі [літеральні типи](./literal-types.md).

## Захоплення ключових імен

Оператор `keyof` дозволяє захоплювати імена ключів типу. Наприклад, ви можете використовувати його, щоб захопити імена ключів змінної, спочатку отримавши її тип за допомогою `typeof`:

```ts
const colors = {
  red: 'reddish',
  blue: 'bluish'
}
type Colors = keyof typeof colors;

let color: Colors; // те саме, що й let color: "red" | "blue"
color = 'red'; // ок
color = 'blue'; // ок
color = 'anythingElse'; // Помилка: Тип '"anythingElse"' не призначається до типу '"red" | "blue"'
```

Це дозволяє вам легко мати рядки зі значеннями або константами, як ви щойно побачили вище.