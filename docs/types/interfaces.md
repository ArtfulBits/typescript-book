## Інтерфейси

Інтерфейси не мають *нульового* впливу на роботу JS. В TypeScript інтерфейси мають велику потужність для оголошення структури змінних.

Наступні два оголошення еквівалентні, перше використовує *інлайнову анотацію*, друге використовує *інтерфейс*:

```ts
// Приклад A
declare var myPoint: { x: number; y: number; };

// Приклад B
interface Point {
    x: number; y: number;
}
declare var myPoint: Point;
```

Однак краса *Прикладу B* полягає в тому, що якщо хтось створює бібліотеку, яка базується на бібліотеці `myPoint`, щоб додати нові члени, вони можуть легко додати до існуючого оголошення `myPoint`:

```ts
// Lib a.d.ts
interface Point {
    x: number; y: number;
}
declare var myPoint: Point;

// Lib b.d.ts
interface Point {
    z: number;
}

// Your code
var myPoint.z; // Дозволено!
```

Це тому, що **інтерфейси в TypeScript є відкритими**. Це важливий принцип TypeScript, який дозволяє вам імітувати розширюваність JavaScript за допомогою *інтерфейсів*.


## Класи можуть реалізовувати інтерфейси

Якщо ви хочете використовувати *класи*, які повинні відповідати структурі об'єкта, яку хтось оголосив для вас в `інтерфейсі`, ви можете використовувати ключове слово `implements`, щоб забезпечити сумісність:

```ts
interface Point {
    x: number; y: number;
}

class MyPoint implements Point {
    x: number; y: number; // Те саме, що і Point
}
```

При наявності цього `implements` будь-які зміни в зовнішньому інтерфейсі `Point` призведуть до помилки компіляції в вашій кодовій базі, щоб ви могли легко утримувати його в синхронізації:

```ts
interface Point {
    x: number; y: number;
    z: number; // Новий член
}

class MyPoint implements Point { // ПОМИЛКА: відсутній член `z`
    x: number; y: number;
}
```

Зверніть увагу, що `implements` обмежує структуру екземплярів класу, тобто:

```ts
var foo: Point = new MyPoint();
```

І речі, подібні до `foo: Point = MyPoint`, не є тим самим.


## ПОРАДИ

### Не кожен інтерфейс можна легко реалізувати

Інтерфейси призначені для оголошення *будь-якої довільної* структури, яка може бути присутня в JavaScript.

Розгляньте наступний інтерфейс, де щось можна викликати з `new`:

```ts
interface Crazy {
    new (): {
        hello: number
    };
}
```

Ви фактично матимете щось на зразок:

```ts
class CrazyClass implements Crazy {
    constructor() {
        return { hello: 123 };
    }
}
// Тому що
const crazy = new CrazyClass(); // crazy буде {hello:123}
```

Ви можете *оголосити* всі безумство JS там з інтерфейсами і навіть безпечно використовувати їх з TypeScript. Це не означає, що ви можете використовувати класи TypeScript для їх реалізації.