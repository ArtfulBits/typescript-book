* [Анотації параметрів](#parameter-annotations)
* [Анотація типу повернення](#return-type-annotation)
* [Необов'язкові параметри](#optional-parameters)
* [Перевантаження](#overloading)

## Функції
Система типів TypeScript надає багато можливостей для функцій, оскільки вони є основними будівельними блоками композиційної системи.

### Анотації параметрів
Звичайно, ви можете анотувати параметри функції так само, як і інші змінні:

```ts
// анотація змінної
var sampleVariable: { bar: number }

// анотація параметра функції
function foo(sampleParameter: { bar: number }) { }
```

Тут я використовував анотації типів в рядку. Звичайно, ви можете використовувати інтерфейси і т.д.

### Анотація типу повернення

Ви можете анотувати тип повернення після списку параметрів функції з тим самим стилем, як і для змінної, наприклад, `: Foo` у наведеному нижче прикладі:

```ts
interface Foo {
    foo: string;
}

// Тип повернення анотований як `: Foo`
function foo(sample: Foo): Foo {
    return sample;
}
```

Звичайно, я використовував `interface` тут, але ви можете використовувати інші анотації, наприклад, анотації в рядку.

Досить часто вам не *потрібно* анотувати тип повернення функції, оскільки його можна загалом вивести компілятором.

```ts
interface Foo {
    foo: string;
}

function foo(sample: Foo) {
    return sample; // виведений тип повернення 'Foo'
}
```

Однак, загалом, добре додавати ці анотації, щоб допомогти з помилками, наприклад:

```ts
function foo() {
    return { fou: 'John Doe' }; // Ви можливо не знайдете цю помилку в написанні `foo`, поки не буде занадто пізно
}

sendAsJSON(foo());
```

Якщо ви не плануєте повертати нічого з функції, ви можете анотувати її як `:void`. Загалом ви можете пропустити `:void` і залишити його для системи виведення.

### Необов'язкові параметри
Ви можете позначити параметр як необов'язковий:

```ts
function foo(bar: number, bas?: string): void {
    // ..
}

foo(123);
foo(123, 'hello');
```

Альтернативно, ви можете навіть надати значення за замовчуванням (використовуючи `= someValue` після оголошення параметра), яке вставляється для вас, якщо викликач не надає цей аргумент:

```ts
function foo(bar: number, bas: string = 'hello') {
    console.log(bar, bas);
}

foo(123);           // 123, hello
foo(123, 'world');  // 123, world
```

### Перевантаження
TypeScript дозволяє *оголошувати* перевантаження функцій. Це корисно для документації та забезпечення типової безпеки. Розгляньте наступний код:

```ts
function padding(a: number, b?: number, c?: number, d?: any) {
    if (b === undefined && c === undefined && d === undefined) {
        b = c = d = a;
    }
    else if (c === undefined && d === undefined) {
        c = a;
        d = b;
    }
    return {
        top: a,
        right: b,
        bottom: c,
        left: d
    };
}
```

Якщо ви уважно дивитесь на код, ви розумієте, що значення `a`,`b`,`c`,`d` змінюються в залежності від того, скільки аргументів передається. Крім того, функція очікує лише `1`, `2` або `4` аргументи. Ці обмеження можна *застосувати* та *документувати* за допомогою перевантаження функцій. Ви просто оголошуєте заголовок функції кілька разів. Останній заголовок функції є тим, який фактично активний *в середині* тіла функції, але він недоступний для зовнішнього світу.

Це показано нижче:

```ts
// Перевантаження
function padding(all: number);
function padding(topAndBottom: number, leftAndRight: number);
function padding(top: number, right: number, bottom: number, left: number);
// Фактична реалізація, яка є справжньою представницею всіх випадків, які потрібно обробити в тілі функції
function padding(a: number, b?: number, c?: number, d?: number) {
    if (b === undefined && c === undefined && d === undefined) {
        b = c = d = a;
    }
    else if (c === undefined && d === undefined) {
        c = a;
        d = b;
    }
    return {
        top: a,
        right: b,
        bottom: c,
        left: d
    };
}
```

Тут перші три заголовки функцій доступні як дійсні виклики `padding`:

```ts
padding(1); // Ок: all
padding(1,1); // Ок: topAndBottom, leftAndRight
padding(1,1,1,1); // Ок: top, right, bottom, left

padding(1,1,1); // Помилка: не є частиною доступних перевантажень
```

Звичайно, важливо, щоб остаточне оголошення (справжнє оголошення, як бачиться зсередини функції) було сумісним з усіма перевантаженнями. Це тому, що це справжня природа викликів функції, які функція повинна враховувати.

> Перевантаження функцій в TypeScript не має ніяких накладних витрат на час виконання. Воно просто дозволяє документувати спосіб, яким ви очікуєте виклик функції, і компілятор перевіряє решту вашого коду.

### Оголошення функцій
> Швидкий підказка: *Оголошення типів* - це спосіб описувати типи існуючих реалізацій.

Є два способи *оголошення* типу функції без надання реалізації. Наприклад:

```ts
type LongHand = {
    (a: number): number;
};

type ShortHand = (a: number) => number;
```
У цьому прикладі обидва варіанти *точно* еквівалентні. Різниця полягає в тому, коли ви хочете додати перевантаження. Ви можете додавати перевантаження тільки в довгому варіанті оголошення, наприклад:

```ts
type LongHandAllowsOverloadDeclarations = {
    (a: number): number;
    (a: string): string;
};
```

[](### Type Compatibility)