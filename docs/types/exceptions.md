# Обробка винятків

У JavaScript є клас `Error`, який можна використовувати для винятків. Ви кидаєте помилку за допомогою ключового слова `throw`. Ви можете перехопити її за допомогою пари блоків `try` / `catch`, наприклад:

```js
try {
  throw new Error('Щось пішло не так');
}
catch(e) {
  console.log(e);
}
```

## Підтипи помилок

Поза вбудованим класом `Error` є кілька додаткових вбудованих класів помилок, які успадковуються від `Error`, які може кинути середовище виконання JavaScript:

### RangeError

Створює екземпляр, який представляє помилку, яка виникає, коли числова змінна або параметр знаходиться поза своїм дійсним діапазоном.

```js
// Виклик консолі з надто багатьма аргументами
console.log.apply(console, new Array(1000000000)); // RangeError: Invalid array length
```

### ReferenceError

Створює екземпляр, який представляє помилку, яка виникає при дереференції недійсної посилання, наприклад:

```js
'use strict';
console.log(notValidVar); // ReferenceError: notValidVar is not defined
```

### SyntaxError

Створює екземпляр, який представляє помилку синтаксису, яка виникає під час розбору коду, який не є дійсним JavaScript.

```js
1***3; // SyntaxError: Unexpected token *
```

### TypeError

Створює екземпляр, який представляє помилку, яка виникає, коли змінна або параметр не є дійсним типом.

```js
('1.2').toPrecision(1); // TypeError: '1.2'.toPrecision is not a function
```

### URIError

Створює екземпляр, який представляє помилку, яка виникає, коли `encodeURI()` або `decodeURI()` передаються недійсні параметри.

```js
decodeURI('%'); // URIError: URI malformed
```

## Завжди використовуйте `Error`

Початківці розробники JavaScript іноді просто кидають необроблені рядки, наприклад:

```js
try {
  throw 'Щось пішло не так';
}
catch(e) {
  console.log(e);
}
```

*Не робіть цього*. Основна перевага об'єктів `Error` полягає в тому, що вони автоматично відстежують місце їх створення та походження за допомогою властивості `stack`.

Необроблені рядки призводять до дуже болісного досвіду налагодження та ускладнюють аналіз помилок з журналів.

## Ви не повинні кидати помилку

Дозволено передавати об'єкт `Error`. Це звичайне в Node.js коді з зворотним викликом, який приймає зворотний виклик з першим аргументом як об'єктом помилки.

```js
function myFunction (callback: (e?: Error)) {
  doSomethingAsync(function () {
    if (somethingWrong) {
      callback(new Error('Це моя помилка'))
    } else {
      callback();
    }
  });
}
```

## Виняткові випадки

"Винятки повинні бути винятковими" - це загальне кажання в інформатиці. Є кілька причин, чому це так для JavaScript (і TypeScript).

### Невідомо, де воно кидається

Розгляньте наступний фрагмент коду:

```js
try {
  const foo = runTask1();
  const bar = runTask2();
}
catch(e) {
  console.log('Помилка:', e);
}
```

Наступний розробник не може знати, яка функція може кинути помилку. Людина, яка переглядає код, не може знати без читання коду для завдання 1/завдання 2 та інших функцій, які вони можуть викликати і т.д.

### Робить гармонійну обробку складною

Ви можете спробувати зробити це гармонійним з явним перехопленням навколо кожної річі, яка може кинути помилку:

```js
try {
  const foo = runTask1();
}
catch(e) {
  console.log('Помилка:', e);
}
try {
  const bar = runTask2();
}
catch(e) {
  console.log('Помилка:', e);
}
```

Але тепер, якщо вам потрібно передати речі з першого завдання до другого, код стає марудним: (зверніть увагу на мутацію `foo`, яка потребує `let` + явну необхідність анотувати її, оскільки її не можна вивести з повернення `runTask1`):

```ts
let foo: number; // Зверніть увагу на використання `let` та явну анотацію типу
try {
  foo = runTask1();
}
catch(e) {
  console.log('Помилка:', e);
}
try {
  const bar = runTask2(foo);
}
catch(e) {
  console.log('Помилка:', e);
}
```

### Не добре представлено в системі типів

Розгляньте функцію:

```ts
function validate(value: number) {
  if (value < 0 || value > 100) throw new Error('Недійсне значення');
}
```

Використання `Error` для таких випадків - погана ідея, оскільки воно не представлено в типовому визначенні для функції перевірки (яке є `(value: number) => void`). Замість цього краще створити метод перевірки таким чином:

```ts
function validate(value: number): {error?: string} {
  if (value < 0 || value > 100) return {error:'Недійсне значення'};
}
```

І тепер це представлено в системі типів.

> Якщо ви не хочете обробляти помилку дуже загальним (простим / всеосяжним тощо) способом, не кидайте помилку.