## Оголошення типу
TypeScript дозволяє перевизначати його виведений та проаналізований тип будь-яким чином, який вам потрібен. Це робиться за допомогою механізму, який називається "оголошенням типу". Оголошення типу TypeScript - це чисто ви повідомляєте компілятору, що ви знаєте про типи краще, ніж він, і що він не повинен піддавати ваші знання сумніву.

Одним з поширених випадків використання оголошення типу є перенесення коду з JavaScript до TypeScript. Наприклад, розгляньте наступний шаблон:

```ts
var foo = {};
foo.bar = 123; // Помилка: властивість 'bar' не існує на `{}`
foo.bas = 'hello'; // Помилка: властивість 'bas' не існує на `{}`
```

Тут код видає помилку, оскільки *виведений* тип `foo` є `{}`, тобто об'єкт з нульовими властивостями. Тому ви не можете додати `bar` або `bas` до нього. Ви можете виправити це просто за допомогою оголошення типу `as Foo`:

```ts
interface Foo {
    bar: number;
    bas: string;
}
var foo = {} as Foo;
foo.bar = 123;
foo.bas = 'hello';
```

### `as foo` проти `<foo>`
Спочатку було додано синтаксис `<foo>`. Це демонструється нижче:

```ts
var foo: any;
var bar = <string> foo; // bar тепер має тип "string"
```

Однак при використанні підтверджень стилю `<foo>` в JSX виникає неоднозначність в граматиці мови:

```ts
var foo = <string>bar;
</string>
```

Тому зараз рекомендується використовувати `as foo` для забезпечення послідовності.

### Оголошення типу проти кастингу
Причина, чому це не називається "кастингом типу", полягає в тому, що *кастинг* загалом передбачає підтримку під час виконання. Однак *оголошення типу* є чисто компіляційним конструктом і способом надання підказок компілятору щодо того, як ви хочете, щоб ваш код був проаналізований.

### Оголошення вважається шкідливим
У багатьох випадках оголошення дозволить вам легко мігрувати старий код (і навіть копіювати інші зразки коду до вашої кодової бази). Однак ви повинні бути обережні з використанням оголошень. Візьміть наш вихідний код як зразок, компілятор не захистить вас від забуття *дійсно додати обіцяні властивості*:

```ts
interface Foo {
    bar: number;
    bas: string;
}
var foo = {} as Foo;
// аххх .... щось забули?
```

Також ще одна поширена думка полягає в тому, що оголошення використовується як засіб забезпечення *автозаповнення*, наприклад:

```ts
interface Foo {
    bar: number;
    bas: string;
}
var foo = <Foo>{
    // компілятор надасть автозаповнення для властивостей Foo
    // Але розробник може забути додати всі властивості
    // Крім того, цей код ймовірно зламається, якщо Foo буде перероблено (наприклад, додано нову властивість)
};
```

але тут ризик той же, якщо ви забудете властивість, компілятор не буде скаржитися. Краще, якщо ви зробите наступне:

```ts
interface Foo {
    bar: number;
    bas: string;
}
var foo: Foo = {
    // компілятор надасть автозаповнення для властивостей Foo
};
```

У деяких випадках вам може знадобитися створити тимчасову змінну, але принаймні ви не будете робити (можливо, хибні) обіцянки, а замість цього будете покладатися на виведення типу, щоб перевірити це за вас.

### Подвійне оголошення
Оголошення типу, незважаючи на те, що воно трохи небезпечне, як ми показали, не є *повністю відкритим сезоном*. Наприклад, наступний випадок використання є дуже дійсним (наприклад, користувач думає, що переданий події буде більш конкретним випадком події), і оголошення типу працює очікувано:

```ts
function handler (event: Event) {
    let mouseEvent = event as MouseEvent;
}
```

Однак наступне ймовірно є помилкою, і TypeScript буде скаржитися, як показано, незважаючи на підтвердження типу користувача:

```ts
function handler(event: Event) {
    let element = event as HTMLElement; // Помилка: Ні 'Event', ні тип 'HTMLElement' не можуть бути призначені один одному
}
```

Якщо *ви все ще хочете той тип, ви можете використовувати подвійне оголошення*, але спочатку оголошуючи `unknown` (або `any`), який сумісний з усіма типами, і тому компілятор більше не скаржиться:

```ts
function handler(event: Event) {
    let element = event as unknown as HTMLElement; // Ок!
}
```

#### Як TypeScript визначає, що одне оголошення недостатньо
В основному, оголошення з типу `S` до `T` вдається, якщо або `S` є підтипом `T`, або `T` є підтипом `S`. Це забезпечує додаткову безпеку при оголошенні типів ... абсолютно дикі оголошення можуть бути дуже небезпечними, і вам потрібно використовувати `unknown` (або `any`), щоб бути настільки небезпечним.

#### `as any as` проти `as unknown as`
Обидва *рівно небезпечні* на думку TypeScript. Використовуйте те, що робить вас щасливими. Розгляньте наступне:

* Лінтери віддають перевагу `unknown` (з правилом `no-explicit-any`)
* `any` менше символів, ніж `unknown`