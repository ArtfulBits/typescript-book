### let

Змінні в JavaScript з ключовим словом `var` мають *область видимості функції*. Це відрізняється від багатьох інших мов програмування (C# / Java тощо), де змінні мають *область видимості блоку*. Якщо ви думаєте про JavaScript з точки зору *області видимості блоку*, то очікуєте, що наступний код виведе `123`, але насправді він виведе `456`:

```ts
var foo = 123;
if (true) {
    var foo = 456;
}
console.log(foo); // 456
```

Це тому, що `{` не створює нову *область видимості змінної*. Змінна `foo` внутрішнього блоку `if` є такою ж, як і змінна зовнішнього блоку. Це є поширеною проблемою в програмуванні на JavaScript. Тому TypeScript (і ES6) вводить ключове слово `let`, щоб дозволити визначати змінні з справжньою *областю видимості блоку*. Якщо використовувати `let` замість `var`, то отримаєте змінну, яка є справжнім унікальним елементом, відокремленим від того, що ви визначили зовнішньої області видимості. Той самий приклад з демонстрацією `let`:

```ts
let foo = 123;
if (true) {
    let foo = 456;
}
console.log(foo); // 123
```

Ще одне місце, де `let` захистить від помилок - це цикли.

```ts
var index = 0;
var array = [1, 2, 3];
for (let index = 0; index < array.length; index++) {
    console.log(array[index]);
}
console.log(index); // 0
```

У всій щирості, ми вважаємо, що краще використовувати `let` у всіх випадках, оскільки це призводить до меншої кількості несподіванок для нових і існуючих розробників.

#### Функції створюють нову область видимості

Оскільки ми згадали про це, ми хотіли б демонструвати, що функції створюють нову область видимості змінної в JavaScript. Розгляньте наступний код:

```ts
var foo = 123;
function test() {
    var foo = 456;
}
test();
console.log(foo); // 123
```

Це працює так, як ви очікуєте. Без цього було б дуже важко писати код на JavaScript.

#### Згенерований JS

JS, який генерує TypeScript, просто перейменовує змінну `let`, якщо вже існує подібне ім'я в оточуючій області видимості. Наприклад, наступне генерується без змін:

```ts
if (true) {
    let foo = 123;
}

// стає //

if (true) {
    var foo = 123;
}
```

Однак, якщо ім'я змінної вже використовується в оточуючій області видимості, то генерується нове ім'я змінної, як показано нижче (зверніть увагу на `foo_1`):

```ts
var foo = '123';
if (true) {
    let foo = 123;
}

// стає //

var foo = '123';
if (true) {
    var foo_1 = 123; // Перейменовано
}
```

#### Switch

Ви можете обгорнути свої тіла `case` в `{}`, щоб надійно використовувати імена змінних в різних операторах `case`, як показано нижче:

```ts
switch (name) {
    case 'x': {
        let x = 5;
        // ...
        break;
    }
    case 'y': {
        let x = 10;
        // ...
        break;
    }
}
```

#### let в замиканнях

Розповсюджене питання на співбесіді для розробника JavaScript полягає в тому, який журнал виведе наступний простий файл:

```ts
var funcs = [];
// створити кілька функцій
for (var i = 0; i < 3; i++) {
    funcs.push(function() {
        console.log(i);
    })
}
// викликати їх
for (var j = 0; j < 3; j++) {
    funcs[j]();
}
```

Очікувалось, що виведе `0,1,2`. Дивно, але він виведе `3` для всіх трьох функцій. Причина полягає в тому, що всі три функції використовують змінну `i` з зовнішньої області видимості, і коли ми виконуємо їх (у другому циклі), значення `i` буде `3` (це умова завершення першого циклу).

Виправленням буде створення нової змінної в кожній ітерації циклу. Як ми вже вивчили, ми можемо створити нову область видимості змінної, створивши нову функцію та відразу її виконавши (тобто шаблон IIFE з класів `(function() { /* body */ })();`) , як показано нижче:

```ts
var funcs = [];
// створити кілька функцій
for (var i = 0; i < 3; i++) {
    (function() {
        var local = i;
        funcs.push(function() {
            console.log(local);
        })
    })();
}
// викликати їх
for (var j = 0; j < 3; j++) {
    funcs[j]();
}
```

Тут функції закриваються (тому їх називають `замиканнями`) на *локальну* змінну (зручно названу `local`) і використовують її замість змінної циклу `i`.

> Зверніть увагу, що замикання мають вплив на продуктивність (їм потрібно зберігати оточуючий стан).

Ключове слово ES6 `let` в циклі матиме таку ж поведінку, як у попередньому прикладі:

```ts
var funcs = [];
// створити кілька функцій
for (let i = 0; i < 3; i++) { // Зверніть увагу на використання let
    funcs.push(function() {
        console.log(i);
    })
}
// викликати їх
for (var j = 0; j < 3; j++) {
    funcs[j]();
}
```

Використання `let` замість `var` створює змінну `i`, унікальну для кожної ітерації циклу.

#### Висновок

`let` дуже корисний для великої частини коду. Він може значно покращити читабельність вашого коду та зменшити ймовірність програмної помилки. 

[](https://github.com/olov/defs/blob/master/loop-closures.md)