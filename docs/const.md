### const
Константи.

`const` є дуже бажаним доповненням, запропонованим ES6/TypeScript. Це дозволяє вам створювати змінні, значення которих не можно змінити. Це добре як з точки зору документації, так і з точки зору часу виконання. Щоб використовувати const, просто замініть `var` або `let` на `const`:

```ts
const foo = 123;
```

> Синтаксис TS набагато кращий (IMHO), ніж у інших мовах, які змушують користувача вводити щось на зразок `let constant foo` , тобто змінна + специфікатор поведінки.

`const` є хорошою практикою як для зручності читання, так і для підтримки та уникає використання *magic literals* ("магічних" значень), наприклад

```ts
// Низька читабельність та не зрозуміло, чому саме 10?
if (x > 10) {
}

// Краще!
const maxRows = 10;
if (x > maxRows) {
}
```

#### const declarations must be initialized

ВАЖЛИВО! Константа повинна отримати значення при створені.

Нижче наведено помилку компілятора:

```ts
const foo; // ПОМИЛКА: необхідно ініціалізувати оголошення const
```

#### Left hand side of assignment cannot be a constant

Константи є незмінними після створення, тому якщо ви спробуєте призначити їм нове значення, це буде помилкою компілятора:

```ts
const foo = 123;
foo = 456; // ПОМИЛКА
```

#### Block Scoped

`Const` має блочну область видимості , як ми бачили з  [`let`](./let.md):

```ts
const foo = 123;
if (true) {
    const foo = 456; // Можливо, тому що це інша знінна foo
}
```

#### Deep immutability

`const` також працює з об’єктними літералами, в цьому припаді незмінною є *reference* (посилання) на змінну:

```ts
const foo = { bar: 123 };
foo = { bar: 456 }; // // ПОМИЛКА: не можна присвоїти змінній інший обʼєкт
```

Однак він все ще дозволяє змінювати властивості об’єктів, як показано нижче:

```ts
const foo = { bar: 123 };
foo.bar = 456; // Allowed!
console.log(foo); // { bar: 456 }
```

#### Prefer const

Завжди використовуйте const , якщо ви не плануєте пізніше ініціалізувати змінну, або виконати перепризначення (використовуйте let для таких випадків).
