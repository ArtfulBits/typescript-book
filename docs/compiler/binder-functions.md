### Функції зв'язування (Binder)
Дві ключові функції зв'язування - це `bindSourceFile` та `mergeSymbolTable`. Давайте розглянемо їх детальніше.

#### `bindSourceFile`
В основному перевіряє, чи визначений `file.locals`. Якщо ні, він передає управління функції `bind` (локальній функції).

Примітка: `locals` визначено у `Node` і має тип `SymbolTable`. Зверніть увагу, що `SourceFile` також є `Node`  (фактично кореневим вузлом в AST).

ПОРАДА: локальні функції широко використовуються в компіляторі TypeScript. Локальна функція, скоріш за все, використовує змінні з батьківської функції (захоплені за допомогою замикання). У випадку `bind` (локальна функція в межах `bindSourceFile`) вона (або функція, яку вона викликає) налаштовує `symbolCount`, `classifiableNames` та інші значення, які потім зберігаються у поверненому `SourceFile`.

#### `bind`
Функція `bind` працює з будь-яким об'єктом типу `Node` (не тільки з `SourceFile`). По-перше, вона призначає значення для `node.parent` (якщо змінна `parent` була налаштована... це також те, що `binder` робить під час обробки в межах функції `bindChildren`), далі передає управління до функції `bindWorker`, яка виконує *основну* роботу. Нарешті, вона викликає функцію `bindChildren` (функція, яка просто зберігає стан `binder`, наприклад, поточний `parent`, у своїх локальних змінних, далі викликає `bind` для кожного дочірнього вузла і наостанок, відновлює стан байндера). Тепер давайте розглянемо найцікавішу функцію `bindWorker`.

#### `bindWorker`
Ця функція вмикає `node.kind` (типу `SyntaxKind`) і делегує роботу відповідній функції `bindFoo` (також визначеної у `binder.ts`). Наприклад, якщо `node` є `SourceFile` він викликає (у випадку зовнішнього модуля файлу) `bindAnonymousDeclaration`

#### `bindFoo`
Існують кілька типових шаблонів для функцій `bindFoo`, а також кілька вспоміжних функцій, якими вони користуються. Одна функція, яка майже завжди використовується, - це функція `createSymbol`. Нижче наведено її повний варіант:

```typescript
function createSymbol(flags: SymbolFlags, name: string): Symbol {
    return {
        flags,
        name,
        declarations: undefined,
        valueDeclaration: undefined
    };
}
```

```ts
функція createSymbol(flags: SymbolFlags, name: string): Symbol {
    symbolCount++;
    повернути новий Symbol(flags, name);
}
```

Як можна побачити, `bindFoo` просто оновлює значення `symbolCount` (локальної змінної в функції `bindSourceFile`) та створює символ із вказаними параметрами.