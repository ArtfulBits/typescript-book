## Type Instantiation for Generics

Скажімо, у вас є щось, що має загальний параметр, наприклад. клас `Foo`:

```ts
class Foo<T>{
	foo: T;
}
```

Ви хочете створити для нього спеціалізовану версію для певного типу. Шаблон полягає в тому, щоб скопіювати елемент у нову змінну та надати йому анотацію типу із заміною узагальнених типів на конкретні типи. наприклад якщо вам потрібен клас `Foo<number>`:

```ts
class Foo<T>{
	foo: T;
}
let FooNumber = Foo as { new ():Foo<number> }; // ref 1
```
У `посиланні 1` ви говорите, що `FooNumber` — це те саме, що `Foo`, але розглядаєте його як щось, що при виклику оператора `new` дає екземпляр `Foo<Number>`.

### Inheritance
Шаблон твердження Type є небезпечним, оскільки він довіряє вам, що ви робите правильні речі. Загальним шаблоном в інших мовах *для класів* є просто використання спадкування:

```ts
class FooNumber extends Foo<number>{}
```

Одне застереження: якщо ви використовуєте декоратори для базового класу, успадкований клас може не мати такої самої поведінки, як базовий клас (він більше не обгортається декоратором).

Звичайно, якщо ви не спеціалізовали класи, вам все одно доведеться придумати шаблон примусу/твердження, який працює, тому ми спочатку показали загальний шаблон твердження, наприклад:

```ts
function id<T>(x: T) { return x; }
const idNum = id as {(x:number):number};
```

> Натхненний цим [питанням stackoverflow](http://stackoverflow.com/a/34864705/390330)
