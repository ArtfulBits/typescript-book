## Проблеми з `export default`

Припустимо, що у вас є файл `foo.ts` з наступним вмістом:

```ts
class Foo {
}
export default Foo;
```

Ви імпортуєте його (у `bar.ts`) за допомогою синтаксису ES6 наступним чином:

```ts
import Foo from "./foo";
```

Тут є кілька проблем з підтримкою:
* Якщо ви перейменуєте `Foo` у `foo.ts`, то він не перейменується у `bar.ts`.
* Якщо ви потрапите у ситуацію, коли потрібно експортувати більше речей з `foo.ts` (що є тим, що мають багато ваших файлів), то вам доведеться маневрувати синтаксисом імпорту.

З цієї причини я рекомендую прості експорти + імпорт з деструктуризацією. Наприклад, `foo.ts`:

```ts
export class Foo {
}
```
А потім:

```ts
import { Foo } from "./foo";
```

Нижче я також приводжу кілька інших причин.

### Погана відкритість
Відкритість дуже погана для експорту за замовчуванням. Ви не можете досліджувати модуль з інтелектуальним підказуванням, щоб побачити, чи є в ньому експорт за замовчуванням чи ні.

З експортом за замовчуванням ви тут нічого не отримуєте (можливо, він експортує за замовчуванням / можливо, ні `¯\_(ツ)_/¯`):
```
import /* here */ from 'something';
```

Без експорту за замовчуванням ви отримуєте гарне інтелектуальне підказування тут: 

```
import { /* here */ } from 'something';
```

### Автодоповнення 
Незалежно від того, чи ви знаєте про експорти, ви навіть автодоповнення на цьому місці курсора `import {/*here*/} from "./foo";`. Це дозволяє вашим розробникам трохи полегшити роботу з зап'ястям.

### Сумісність з CommonJS
З `default` є жахливий досвід для користувачів CommonJS, які повинні `const {default} = require('module/foo');` замість `const {Foo} = require('module/foo')`. Ймовірно, ви захочете перейменувати експорт `default` на щось інше при імпорті.

### Захист від помилок при написанні
Ви не отримуєте помилок при написанні, якщо один розробник робить `import Foo from "./foo";`, а інший робить `import foo from "./foo";`

### Автоматичний імпорт TypeScript
Швидкий автоматичний імпорт працює краще. Ви використовуєте `Foo`, а автоматичний імпорт напише `import { Foo } from "./foo";`, оскільки це добре визначене ім'я, експортоване з модуля. Деякі інструменти там спробують магічно прочитати та *вивести* ім'я для експорту за замовчуванням, але магія не завжди працює.

### Повторний експорт
Повторний експорт є загальним для кореневого файлу `index` у пакетах npm, і змушує вас вручну називати експорт за замовчуванням, наприклад, `export { default as Foo } from "./foo";` (за замовчуванням) проти `export * from "./foo"` (за іменованими експортами).

### Динамічний імпорт
Експорти за замовчуванням погано названі як `default` в динамічних `import`s, наприклад 

```ts
const HighCharts = await import('https://code.highcharts.com/js/es-modules/masters/highcharts.src.js');
HighCharts.default.chart('container', { ... }); // Зверніть увагу на `.default`
```

Набагато краще з іменованими експортами: 

```ts
const {HighCharts} = await import('https://code.highcharts.com/js/es-modules/masters/highcharts.src.js');
HighCharts.chart('container', { ... }); // Зверніть увагу на `.default`
```


### Потрібні два рядки для не-класу / не-функції

Може бути одним оператором для функції / класу, наприклад: 

```ts
export default function foo() {
}
```

Може бути одним оператором для *не названих / не типових* об'єктів, наприклад: 

```ts
export default {
  notAFunction: 'Yeah, I am not a function or a class',
  soWhat: 'The export is now *removed* from the declaration'
};
```

Але інакше потрібно два оператори:
```ts
// Якщо вам потрібно назвати його (тут `foo`) для локального використання АБО потрібно анотувати тип (тут `Foo`)
const foo: Foo = {
  notAFunction: 'Yeah, I am not a function or a class',
  soWhat: 'The export is now *removed* from the declaration'
};
export default foo;
```