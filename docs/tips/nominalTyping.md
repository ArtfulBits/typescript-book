## Номінальне типування
Система типів TypeScript є структурною [і це одна з головних переваг](../why-typescript.md). Однак, є реальні випадки використання, коли ви хочете, щоб дві змінні відрізнялися, оскільки вони мають різні *імена типів*, навіть якщо вони мають однакову структуру. Дуже поширеним випадком є *ідентифікаторні* структури (які, як правило, є просто рядками з семантикою, пов'язаною з їх *іменем* в мовах програмування, таких як C# / Java).

У спільноті сформувалися деякі шаблони. Я покриваю їх у порядку зменшення особистої переваги:

## Використання літеральних типів

Цей шаблон використовує дженерики та літеральні типи:

```ts
/** Generic Id type */
type Id<T extends string> = {
  type: T,
  value: string,
}

/** Specific Id types */
type FooId = Id<'foo'>;
type BarId = Id<'bar'>;

/** Optional: constructors functions */
const createFoo = (value: string): FooId => ({ type: 'foo', value });
const createBar = (value: string): BarId => ({ type: 'bar', value });

let foo = createFoo('sample')
let bar = createBar('sample');

foo = bar; // Помилка
foo = foo; // Ок
```

* Переваги
  - Не потрібні жодні підтвердження типу
* Недолік
  - Структура `{type, value}` може бути небажаною та потребувати підтримки серіалізації сервера

## Використання Enums
[Enums in TypeScript](../enums.md) пропонують певний рівень номінального типування. Два типи переліку не є рівними, якщо вони відрізняються за іменем. Ми можемо використовувати цей факт, щоб забезпечити номінальне типування для типів, які інакше мають структурну сумісність.

Обхідний шлях включає:
* Створення переліку *бренду*.
* Створення типу як *перетин* (`&`) переліку бренду + фактичної структури.

Це продемонстровано нижче, де структура типів є просто рядком:

```ts
// FOO
enum FooIdBrand { _ = "" };
type FooId = FooIdBrand & string;

// BAR
enum BarIdBrand  { _ = "" };
type BarId = BarIdBrand & string;

/**
 * Usage Demo
 */
var fooId: FooId;
var barId: BarId;

// Safety!
fooId = barId; // помилка
barId = fooId; // помилка

// Newing up
fooId = 'foo' as FooId;
barId = 'bar' as BarId;

// Обидва типи сумісні з базовим
var str: string;
str = fooId;
str = barId;
```

Зверніть увагу, як переліки брендів, ``FooIdBrand`` та ``BarIdBrand`` вище, мають по одному члену (`_`), який відображає порожній рядок, як вказано у ``{ _ = "" }``. Це змушує TypeScript вважати, що це переліки на основі рядків зі значеннями типу ``string``, а не переліки зі значеннями типу ``number``. Це необхідно, оскільки TypeScript вважає порожній перелік (``{}``) числовим переліком, і згідно з TypeScript 3.6.2 перетин числового ``enum`` та ``string`` є ``never``.

## Використання інтерфейсів

Оскільки `numbers` сумісні з типами `enum`, попередній метод не можна використовувати для них. Замість цього ми можемо використовувати інтерфейси, щоб розірвати структурну сумісність. Цей метод все ще використовується командою компілятора TypeScript, тому варто згадати. Префікс `_` та суфікс `Brand` - це конвенція, яку я наполегливо рекомендую (і [яку дотримується команда TypeScript](https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698)).

Обхідний шлях включає наступне:
* додавання невикористовуваної властивості до типу, щоб розірвати структурну сумісність.
* використання підтвердження типу при необхідності нового або зменшення розміру.

Це продемонстровано нижче:

```ts
// FOO
interface FooId extends String {
    _fooIdBrand: string; // Щоб запобігти помилкам типу
}

// BAR
interface BarId extends String {
    _barIdBrand: string; // Щоб запобігти помилкам типу
}

/**
 * Usage Demo
 */
var fooId: FooId;
var barId: BarId;

// Safety!
fooId = barId; // помилка
barId = fooId; // помилка
fooId = <FooId>barId; // помилка
barId = <BarId>fooId; // помилка

// Newing up
fooId = 'foo' as any;
barId = 'bar' as any;

// Якщо вам потрібен базовий рядок
var str: string;
str = fooId as any;
str = barId as any;
```