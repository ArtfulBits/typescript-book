## Lazy Object Literal Initialization
Лінива ініціалізація літерального обʼєкту.

Досить часто в базах коду JavaScript ви ініціалізуєте літерали об’єктів наступним чином:

```ts
let foo = {};
foo.bar = 123;
foo.bas = "Hello World";
```

Щойно ви перемістите код у TypeScript, ви почнете отримувати такі помилки:

```ts
let foo = {};
foo.bar = 123; // Error: Властивість 'bar' не існує в обʼєкті '{}'
foo.bas = "Hello World"; // Error: Властивість 'bas' dне існує в обʼєкті '{}'
```

Це тому, що `let foo = {}`, TypeScript *розуміє* що тип `foo` (лівостороння ініціалізації призначення) також є типом виразу праворуч `{}` (це обʼєкт, який немає властивостей). Отже, виникає помилка, якщо ви намагаєтеся призначити властивість, про яку він не знає.

### Ideal Fix
Ідеальний фікс.

*Правильний* спосіб ініціалізації об’єкта в TypeScript полягає в тому, щоб зробити це у призначенні:

```ts
let foo = {
    bar: 123,
    bas: "Hello World",
};
```

Це також чудово підходить для перевірки та підтримки коду.

The quick fix and middle ground *lazy* initialization patterns described below suffer from *mistakenly forgetting to initialize a property*. 
>  Описані нижче шаблони швидкого виправлення та  *лінивої* ініціалізації описані нижче виправляють припад коли *помилково забувають ініціалізувати властивість*

### Quick Fix
Швидкий фікс.

Якщо у вас є велика база коду JavaScript, яку ви переносите на TypeScript, ідеальне виправлення може бути не життєздатним рішенням для вас. У цьому випадку ви можете обережно використовувати *твердження типу*, щоб заглушити компілятор:
```ts
let foo = {} as any;
foo.bar = 123;
foo.bas = "Hello World";
```

### Middle Ground
Середній рівень.

Звичайноб викоростання `any` твердження може бути дуже поганим, оскільки воно порушує безпеку TypeScript. Золотий шлях — створити `interface`, щоб забезпечити
* добру документацію
* безпеку

Код нижче:

```ts
interface Foo {
    bar: number
    bas: string
}

let foo = {} as Foo;
foo.bar = 123;
foo.bas = "Hello World";
```

Ось короткий приклад, який показує, що використання інтерфейсу може допомогти:
```ts
interface Foo {
    bar: number
    bas: string
}

let foo = {} as Foo;
foo.bar = 123;
foo.bas = "Hello World";

// пізніше в коді:
foo.bar = 'Hello Stranger'; // Error: Можливо, ви неправильно написали `bas` як `bar`, не можете призначити рядок числу
```
