# Створення модулів TypeScript для Node.js

* [Урок зі створення модулів TypeScript для Node.js](https://egghead.io/lessons/typescript-create-high-quality-npm-packages-using-typescript)

Використання модулів, написаних на TypeScript, є дуже цікавим, оскільки ви отримуєте велику безпеку на етапі компіляції та автодоповнення (практично виконувану документацію).

Модулі TypeScript можуть бути використані як в nodejs (як є), так і в браузері (за допомогою чогось на зразок webpack).

Створення високоякісного модуля TypeScript є простим. Припустимо, що для вашого пакету необхідна наступна структура папок:

```text
package
├─ package.json
├─ tsconfig.json
├─ src
│  ├─ index.ts
│  ├─ foo.ts
│  └─ ...Всі ваші вихідні файли (створені)
└─ lib
  ├─ index.d.ts.map
  ├─ index.d.ts
  ├─ index.js
  ├─ foo.d.ts.map
  ├─ foo.d.ts
  ├─ foo.js
  └─ ... Всі ваші скомпільовані файли (створені)
```

* `src/index.ts`: Тут ви експортуєте все, що очікуєте використовувати в своєму проекті. Наприклад, `export { Foo } from './foo';`. Експорт з цього файлу робить його доступним для використання, коли хтось робить `import { /* Тут */ } from 'example';`

* У вашому `tsconfig.json`
  * маєте `compilerOptions`: `"outDir": "lib"` + `"declaration": true` + `"declarationMap" : true` < Це генерує `.js` (JavaScript) `.d.ts` (декларації для безпеки типів) та `.d.ts.map` (дозволяє навігацію IDE від `declaration .d.ts` до `source .ts`) у папці lib.
  * маєте `include: ["src"]` < Це включає всі файли з директорії `src`.

* У вашому `package.json` маєте
  * `"main": "lib/index"` < Це говорить про те, що для виконання коду необхідно завантажити `lib/index.js`.
  * `"types": "lib/index"` < Це говорить TypeScript завантажувати `lib/index.d.ts` для перевірки типів. 

Приклад пакету:
* `npm install typestyle` [для TypeStyle](https://www.npmjs.com/package/typestyle)
* Використання: `import { style } from 'typestyle';` буде повністю безпечним з точки зору типів.

### Керування залежностями
#### devDependencies
* Якщо ваш пакет залежить від іншого пакету під час розробки (наприклад, `prettier`), ви повинні встановити його як `devDependency`. Таким чином вони не забруднять `node_modules` споживачів вашого модуля (оскільки `npm i foo` не встановлює `devDependencies` `foo`).
* `typescript` зазвичай є `devDependency`, оскільки ви використовуєте його лише для збірки пакету. Споживачі можуть використовувати ваш пакет з або без TypeScript.
* Якщо ваш пакет залежить від інших пакетів, написаних на JavaScript, і ви хочете використовувати його з безпекою типів у своєму проекті, помістіть їх типи (наприклад, `@types/foo`) у `devDependencies`. Типи JavaScript повинні керуватися *поза межами* основних потоків NPM. Екосистема JavaScript занадто часто порушує типи без семантичного версіонування, тому якщо ваші користувачі потребують типів для цих пакетів, вони повинні встановити версію `@types/foo`, яка працює для них. Якщо ви хочете навести користувачів на думку, щоб вони встановили ці типи, ви можете помістити їх у `peerDependencies`, про які йдеться далі.

#### peerDependencies
Якщо ваш пакет залежить від пакету, з яким він сильно *працює* (на відміну від *працює з*), наприклад, `react`, помістіть їх у `peerDependencies`, так само, як ви зробили б зі звичайними пакетами JS. Щоб перевірити їх локально, ви також повинні помістити їх у `devDependencies`. 

Тепер:
* Під час розробки пакету ви отримаєте версію залежності, яку вказали у `devDependencies`.
* Коли хтось встановлює ваш пакет, вони *не* отримають цю залежність (оскільки `npm i foo` не встановлює `devDependencies` `foo`), але вони отримають попередження, що вони повинні встановити відсутні `peerDependencies` вашого пакету. 

#### dependencies
Якщо ваш пакет *обгортає* інший пакет (призначений для внутрішнього використання навіть після компіляції), помістіть їх у `dependencies`. Тепер, коли хтось встановлює ваш пакет, вони отримають ваш пакет + будь-які залежності.