# noImplicitAny

Є деякі речі, про які неможливо зробити висновок, або їх висновок може призвести до несподіваних помилок. Гарним прикладом є аргументи функції. Якщо ви не анотуєте їх, незрозуміло, що має бути дійсним, а що ні.

```ts
function log(someArg) {
  sendDataToServer(someArg);
}

// Який аргумент вірний а який ні?
log(123);
log('hello world');
```

Отже, якщо ви не анотуєте якийсь аргумент функції, TypeScript припускає `any` і йде далі. По суті, це вимикає перевірку типу для таких випадків, чого очікував би розробник JavaScript. Але це може застати людей, які хочуть високої безпеки, зненацька. Таким чином, існує опція `noImplicitAny`, яка після ввімкнення позначатиме випадки, коли тип не можна визначити, наприклад.

```ts
function log(someArg) { // Error : someArg has an implicit `any` type
  sendDataToServer(someArg);
}
```

Звичайно, ви можете продовжити і описати:

```ts
function log(someArg: number) {
  sendDataToServer(someArg);
}
```

І якщо ви справді бажаєте *нульової безпеки*, ви можете позначити його *явно* як `any`:

```ts
function log(someArg: any) {
  sendDataToServer(someArg);
}
```
