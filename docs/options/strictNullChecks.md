# `strictNullChecks`

За замовчуванням в TypeScript `null` та `undefined` можна призначити будь-якому типу, наприклад:

```ts
let foo: number = 123;
foo = null; // Добре
foo = undefined; // Добре
```

Це моделюється після того, як багато людей пишуть JavaScript. Однак, як і у всьому, TypeScript дозволяє бути *явним* щодо того, що *може бути* призначено `null` або `undefined`.

У режимі строго перевірки на `null`, `null` та `undefined` є різними:

```ts
let foo = undefined;
foo = null; // НЕ добре
```

Допустимо, є інтерфейс `Member`:

```ts
interface Member {
  name: string,
  age?: number
}
```

Не кожен `Member` надасть свій вік, тому `age` є необов'язковою властивістю, що означає, що значення `age` може бути або не бути `undefined`.

`undefined` є коренем усього зла. Він часто призводить до помилок під час виконання. Легко написати код, який викличе помилку `Error` під час виконання:

```ts
getMember()
  .then(member: Member => {
    const stringifyAge = member.age.toString() // Неможливо прочитати властивість 'toString' для 'undefined'
  })
```

Але в режимі строго перевірки на `null` ця помилка буде виявлена на етапі компіляції:

```ts
getMember()
  .then(member: Member => {
    const stringifyAge = member.age.toString() // Об'єкт може бути 'undefined'
  })
```

## Оператор позначення не-нульового значення

Новий оператор постфіксної виразу `!` може використовуватися для того, щоб заявити, що його операнд є не-нульовим та не-визначеним в контекстах, де перевірка типу не може зробити висновок про це. Наприклад:

```ts
// Скомпільовано з --strictNullChecks
function validateEntity(e?: Entity) {
    // Викинути виняток, якщо e є null або недійсною сутністю
}

function processEntity(e?: Entity) {
    validateEntity(e);
    let a = e.name;  // TS ПОМИЛКА: e може бути null.
    let b = e!.name;  // ДОБРЕ. Ми заявляємо, що e є не-нульовим.
}
```

> Зверніть увагу, що це просто заява, і, як і у випадку заяв про тип, *ви відповідальні* за те, щоб значення не було null. Не-нульове заявлення - це в основному ви говорите компілятору "Я знаю, що це не null, тому дозвольте мені використовувати його так, ніби воно не null".

### Оператор позначення визначеного призначення

TypeScript також буде скаржитися на властивості в класах, які не ініціалізовані, наприклад:

```ts
class C {
  foo: number; // ДОБРЕ, якщо призначено в конструкторі
  bar: string = "hello"; // ДОБРЕ, якщо має ініціалізатор властивості
  baz: boolean; // TS ПОМИЛКА: Властивість 'baz' не має ініціалізатора та не призначена безпосередньо в конструкторі.
  constructor() {
    this.foo = 42;
  }
}
```

Ви можете використовувати оператор позначення визначеного призначення після імені властивості, щоб повідомити TypeScript, що ви ініціалізуєте її десь, окрім конструктора, наприклад:

```ts
class C {
  foo!: number;
  // ^
  // Зверніть увагу на цю окличну точку!
  // Це модифікатор "оператора позначення визначеного призначення".
  
  constructor() {
    this.initialize();
  }
  initialize() {
    this.foo = 0;
  }
}
```

Ви також можете використовувати цю заяву з простими заявами змінних, наприклад:

```ts
let a: number[]; // Без заяви
let b!: number[]; // Заява

initialize();

a.push(4); // TS ПОМИЛКА: змінна використовується до призначення
b.push(4); // ДОБРЕ: через заяву

function initialize() {
  a = [0, 1, 2, 3];
  b = [0, 1, 2, 3];
}
```

> Як і всі заяви, ви говорите компілятору довіряти вам. Компілятор не буде скаржитися, навіть якщо код насправді не завжди призначає властивість.