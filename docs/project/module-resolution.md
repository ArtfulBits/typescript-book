# Розв'язання модулів TypeScript

Розв'язання модулів TypeScript намагається моделювати та підтримувати реальні системи/завантажувачі модулів (commonjs/nodejs, amd/requirejs, ES6/systemjs тощо). Найпростішим пошуком є пошук відносного шляху до файлу. Після цього речі стають трохи складнішими *через природу магічного завантаження модулів, яке виконують різні завантажувачі модулів*.

## Розширення файлів

Ви імпортуєте модулі, такі як `foo` або `./foo`. Для будь-якого пошуку файлів TypeScript автоматично перевіряє наявність файлу `.ts` або `.d.ts` або `.tsx` або `.js` (за бажанням) або `.jsx` (за бажанням) в правильному порядку залежно від контексту. Ви **не повинні** надавати розширення файлу з ім'ям модуля (ні `foo.ts`, просто `foo`).

## Відносний файловий модуль

Імпорт з відносним шляхом, наприклад:

```ts
import foo = require('./foo');
```

Каже компілятору TypeScript шукати файл TypeScript за відносним шляхом, наприклад, `./foo.ts` відносно поточного файлу. До цього виду імпорту не застосовується жодна додаткова магія. Звичайно, це може бути довший шлях, наприклад, `./foo/bar/bas` або `../../../foo/bar/bas`, як будь-які інші *відносні шляхи*, які ви звикли використовувати на диску.

## Іменований модуль

Наступний оператор:

```ts
import foo = require('foo');
```

Каже компілятору TypeScript шукати зовнішній модуль в наступному порядку:

* Іменована [декларація модуля](#module-declaration) з файлу, який вже є в контексті компіляції.
* Якщо все ще не вирішено, і ви компілюєте з `--module commonjs` або встановили `--moduleResolution node`, тоді він шукається за алгоритмом розв'язання [*модулів node*](#node-modules).
* Якщо все ще не вирішено, і ви надали `baseUrl` (і за бажанням `paths`), тоді запускається алгоритм розв'язання [*замін шляхів*](#path-substitutions).

Зверніть увагу, що `"foo"` може бути довшим рядком шляху, наприклад, `"foo/bar/bas"`. Ключовим тут є те, що *він не починається з `./` або `../`*.

## Декларація модуля

Декларація модуля виглядає так:

```ts
declare module "foo" {

    /// Деякі оголошення змінних

    export var bar:number; /*приклад*/
}
```

Це робить модуль `"foo"` *імпортованим*.

## Модулі Node

Розв'язання модулів Node насправді майже таке ж, як те, яке використовується Node.js / NPM ([офіційна документація nodejs](https://nodejs.org/api/modules.html#modules_all_together)). Ось проста ментальна модель, яку я маю:

* модуль `foo/bar` буде розв'язуватися до деякого файлу: `node_modules/foo` (модуль) + `foo/bar`

## Заміни шляхів

TODO.

[//Comment1]:https://github.com/Microsoft/TypeScript/issues/2338
[//Comment2]:https://github.com/Microsoft/TypeScript/issues/5039
[//Comment3ExampleRedirectOfPackageJson]:https://github.com/Microsoft/TypeScript/issues/8528#issuecomment-219172026
[//Coment4ModuleResolutionInHandbook]:https://github.com/Microsoft/TypeScript-Handbook/blob/release-2.0/pages/Module%20Resolution.md#base-url